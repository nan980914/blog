(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{383:function(a,t,s){"use strict";s.r(t);var n=s(44),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"作用域与闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域与闭包"}},[a._v("#")]),a._v(" 作用域与闭包")]),a._v(" "),s("h2",{attrs:{id:"作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[a._v("#")]),a._v(" 作用域")]),a._v(" "),s("p",[a._v("几乎所有编程语言都具有「存储变量的值，之后对这个变量进行访问和修改」的能力。")]),a._v(" "),s("p",[a._v("所以在将变量引入程序后，需要一套规则来存储变量并可以方便的找到这些变量。这套规则就被称为作用域。")]),a._v(" "),s("p",[a._v("作用域本质上就是程序存储和访问变量的一套规则。")]),a._v(" "),s("h2",{attrs:{id:"理解作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解作用域"}},[a._v("#")]),a._v(" 理解作用域")]),a._v(" "),s("p",[a._v("尽管我们常说JS是一门“动态”语言，但它其实是一门编译语言。")]),a._v(" "),s("p",[a._v("但与传统的编程语言不一样，JS不是提前编译的。大部分编译发生在代码执行前的几微秒的时间内。")]),a._v(" "),s("p",[a._v("对于"),s("code",[a._v("var a = 1")]),a._v("这样一行代码，会进行如下处理：")]),a._v(" "),s("ol",[s("li",[a._v("编译阶段：编译器会查找当前作用域，看看是否已经存在a这样一个变量。如果有，就会忽略这个声明，继续往下编译；如果没有，就会在当前作用域里声明一个新的变量a。然后为引擎生成运行运行时所需要的代码。")]),a._v(" "),s("li",[a._v("运行阶段：JS引擎会查找当前作用域看是否存在a这样一个变量。如果有，就会给a赋值，如果没找到，会继续向上层作用域去找，直到找到变量a，并给其赋值（其实这一层层的查找中，层层递进的作用域就形成了作用域链）。如果最终也没找到，那么就会抛出一个异常来。")])]),a._v(" "),s("h2",{attrs:{id:"lhs和rhs是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lhs和rhs是什么"}},[a._v("#")]),a._v(" LHS和RHS是什么？")]),a._v(" "),s("p",[a._v("正如上面我们说的，编译器在编译过程中生成了代码，引擎执行的时候，会通过查找变量a来判断它是否已经被声明过（是否存在）。")]),a._v(" "),s("p",[a._v("LHS和RHS就是编译器在查找变量时的两种方式。L代表Left左侧，R代表Right右侧。")]),a._v(" "),s("p",[a._v("这个左和右是看变量出现在赋值操作的左侧还是右侧。")]),a._v(" "),s("p",[a._v("比如还是例子：")]),a._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n")])])]),s("p",[a._v("这个变量a出现在赋值操作的左侧，引擎就会为变量a执行LHS查询。")]),a._v(" "),s("p",[a._v("其实讲的更准确一点，RHS查询就是简单的查找某个变量的值。而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。")]),a._v(" "),s("p",[a._v("比如以下例子：")]),a._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[a._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a\n")])])]),s("p",[a._v('其实这两行代码对变量a都是RHS查询，所以RHS更准确是表明"非左侧"。')]),a._v(" "),s("p",[a._v("LHS查询意味着变量赋值或写入内存，强调的是“写”。")]),a._v(" "),s("p",[a._v("RHS查询意味着变量查找或从内存中读取，强调的是“读”。")]),a._v(" "),s("h2",{attrs:{id:"词法作用域-动态作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域-动态作用域"}},[a._v("#")]),a._v(" 词法作用域？动态作用域？")]),a._v(" "),s("p",[a._v("作用域共有两种主要的工作模型。")]),a._v(" "),s("ul",[s("li",[a._v("第一种是最普遍的，被大多数编程语言所采用的"),s("strong",[a._v("词法作用域")])]),a._v(" "),s("li",[a._v("第二种是"),s("strong",[a._v("动态作用域")]),a._v("，仍被一些编程语言在使用，比如bash脚本，Perl中的一些模式等")])]),a._v(" "),s("p",[a._v("在JS语言范畴内讨论「作用域」其实指的就是词法作用域。")]),a._v(" "),s("p",[a._v("词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（如果你没有使用eval()和with）。而动态作用域是让作用域作为一个运行时被动态确定的形式。我们可以通过以下示例来说明：")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("这段代码最后的输出应该是2，foo()中的console.log(a)通过RHS查询查找到了全局中的a变量。这就是JS中的词法作用域。")]),a._v(" "),s("p",[a._v("简单的说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。")]),a._v(" "),s("p",[a._v("无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。")]),a._v(" "),s("p",[a._v("而动态作用域只关心它们在何处被调用。换句话说，作用域链是基于调用栈的，而不是代码中书写的作用域嵌套。")]),a._v(" "),s("p",[a._v("所以如果JS是动态作用域的话，那么上面的例子中foo将会顺着调用栈在调用foo的地方查找a，并找到值为3的变量a，最终输出3。")]),a._v(" "),s("p",[a._v("总结来说：")]),a._v(" "),s("ul",[s("li",[a._v("词法作用域：在代码书写的时候完成划分，作用域链沿着它定义的位置向外延伸。")]),a._v(" "),s("li",[a._v("动态作用域：写代码运行的时候完成划分，作用域链沿着它的调用栈向外延伸。")])]),a._v(" "),s("h2",{attrs:{id:"欺骗词法-修改词法作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#欺骗词法-修改词法作用域"}},[a._v("#")]),a._v(" 欺骗词法，修改词法作用域")]),a._v(" "),s("p",[a._v("词法作用域完全由写代码期间函数定义的位置来决定，那么如何改变作用域呢？")]),a._v(" "),s("p",[a._v("JS中有两个方法来实现这个目的，能在运行过程中改变作用域，就是eval和with。（但写代码不要用这两个东西哈）")]),a._v(" "),s("h2",{attrs:{id:"理解闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解闭包"}},[a._v("#")]),a._v(" 理解闭包")]),a._v(" "),s("p",[a._v("闭包其实是基于词法作用域书写代码时所产生的自然结果。")]),a._v(" "),s("p",[a._v("当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前的词法作用域之外执行。")]),a._v(" "),s("p",[a._v("我们看下面一段代码，就清晰的展示了闭包：")]),a._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[a._v("function foo() "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  var a = "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(";\n  function bar() "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    console.log( a );\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  return bar;\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\nvar baz = foo();\nbaz(); "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2 —— 这就是闭包的效果。")]),a._v("\n")])])]),s("p",[a._v("基于词法作用域的查找规则，函数bar()可以访问外部作用域变量a。")]),a._v(" "),s("p",[a._v("在这个例子中，bar()被赋值给baz，在自己的词法作用域之外的地方执行。")]),a._v(" "),s("p",[a._v("在foo()被执行完之后，其内部的作用域并没有被销毁。原因是bar()还在使用这个作用域，因此不会被垃圾回收。")]),a._v(" "),s("p",[a._v("bar()依然持有对原作用域的引用，这个引用就叫做闭包。")]),a._v(" "),s("p",[a._v("再来看一段常见的代码：")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("message")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("timer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" message "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1000")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Hello world!"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("在执行完wait这个函数后，其内部作用域并不会消失。timer函数还保存着对其作用域的引用，词法作用域在这个过程中保持完整。")]),a._v(" "),s("p",[a._v("这就叫闭包。")]),a._v(" "),s("p",[a._v("发散思维以此类推，何时何地，如果将函数（访问它们的词法作用域）当做参数传递，就会看到闭包在这个函数中的应用。")]),a._v(" "),s("p",[a._v("在"),s("strong",[a._v("定时器、事件监听器(addEventListener)、Ajax请求、跨窗口通信、Web Worker等任务")]),a._v("中，只要使用了回调函数，都是在使用闭包。")]),a._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),s("p",[a._v("当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。")]),a._v(" "),s("p",[a._v("了解了闭包的真正原理后，就会发现我们的代码其实处处都充斥了闭包。")]),a._v(" "),s("p",[a._v("再来一问：“你怎么理解JS中的闭包？”")])])}),[],!1,null,null,null);t.default=r.exports}}]);